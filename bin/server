#!/usr/bin/env -S node -r esm

import 'localenv';
const { Command, Option } = require('commander');

const { version } = require('../package');
const { EOL } = require('os');

const program = new Command();
const debug = require('debug')('tunnelout-server:bin');

import { cwd } from 'process';
import Debug from 'debug';
import CreateServer from '../server';
import fs from 'fs';

function stringIsAValidUrl(s) {
    try {
        new URL(s);
        return true;
    } catch (err) {
        return false;
    }
}

function fileAccess(strFile) {
    try {
        fs.accessSync(strFile, fs.constants.R_OK);
    } catch (err) {
        if (err != undefined && 'code' in err && err.code == 'EACCES') {
            return 'access failed: ' + strFile;
        } else {
            return 'file not found: ' + strFile;
        }
    }
    return true;
}

function envToParam(envStr) {
    let optKey = envStr.substring(3).toLowerCase();
    optKey = optKey.replace(/(_([a-z])(?!\s))/g, function (match, p1, p2) {
        return p2.toUpperCase();
    });
    return optKey;
}

function optionToParam(str) {
    return (
        '--' +
        str.replace(/([A-Z])(?!\s)/g, function (match, p1) {
            return '-' + p1.toLowerCase();
        })
    );
}

program.showHelpAfterError();
program.showSuggestionAfterError();
program.version(version);

program
    .usage('--port <number> [options]')
    .addOption(new Option('-p, --port [number]', 'Listen on this port for outside requests aka public port').default(443).env('TO_PORT').makeOptionMandatory())
    .addOption(new Option('-a, --ipaddress <number>', 'IP address to bind to').default('0.0.0.0').env('TO_IPADDRESS'))
    .addOption(new Option('-d, --domain <string>','Specify the base domain name. This is optional if hosting tunnelOut from a regular example.com domain.' + EOL + 'This is required if hosting a tunnelOut server from a subdomain (i.e. subdomain.example.dom where clients will be client-app.subdomain.example.com').env('TO_DOMAIN'))
    .addOption(new Option('-m, --max-sockets <number>', 'Maximum number of tcp sockets each client is allowed to establish at one time (the tunnels)').default(10).env('TO_MAX_SOCKETS'))
    .addOption(new Option('-l, --landing <string>', 'The landing page to redirect from root domain access').default('https://google.com').env('TO_LANDING'))
    .addOption(new Option('-c, --clientvalid <string>', 'Client agent string to validate against').default('tunnelout').env('TO_CLIENTVALID'))
    .addOption(new Option('-i, --insecure', 'Use this flag to indicate tunnel over insecure http').default(false).env('TO_INSECURE'))
    .addOption(new Option('-k, --kicksameip', 'If an new connection is requested from same ip and same client id the allow kick/disconnect the existing client').default(false).env('TO_KICKSAMEIP'))
    .addOption(new Option('-nr, --nohttpredir', 'If set and running a secure/https server the server won\'t redirect http traffic to https').default(false).env('TO_NOHTTPREDIR'))
    .addOption(new Option('-ps, --public-server','If set it allows anyone to connect. If set the client has to provide a valid client key in then x-client-key header - (client keys are stored in the --clients-file)').default(false).env('TO_PUBLIC_SERVER'))
    .addOption(new Option('-pf, --key-file <path>', 'Path to certificate key file (privkey.pem) for the HTTPS server. Required when running secure server').env('TO_KEY_FILE'))
    .addOption(new Option('-cf, --cert-file <path>', 'Path to certificate chain/cert file (fullchain.pem) for the HTTPS server. Required when running secure server').env('TO_CERT_FILE'))
    .addOption(new Option('-cl, --clients-file <path>', 'Path to clients list (JSON format) file containing client name and their "reserved" host name').env('TO_CLIENTS_FILE'))
    .addOption(new Option('-mc, --max-client-connections <number>', 'When using the clients list and allowing client-override how many tunnels is a client allowed to make').default(1).env('TO_MAX_CLIENT_CONNECTIONS'))
    .addOption(new Option('-co, --client-override', 'Set this to allow the client to override its assigned subdomain when using the clients file method').default(false).env('TO_CLIENT_OVERRIDE'))
    .addOption(new Option('-ak, --apikey <string>', 'The value that must be sent in the x-api-key/authorization header of the API request to be validated. False will disable the API.').default(false).env('TO_APIKEY'))
    .addOption(new Option('-du, --dashboard-user <string>', 'The username used for authorization to access the main admin dashboard').env('TO_DASHBOARD_USER'))
    .addOption(new Option('-dp, --dashboard-pass <string>', 'The password used for authorization to access the main admin dashboard').env('TO_DASHBOARD_PASS'))
    .addOption(new Option('-st, --site-title <string>', 'Alternative site title for the server').env('TO_SITETITLE'))
    .addOption(new Option('-sf, --site-favicon <string>', 'Alternative favicon the server').env('TO_FAVICON'))
    .addOption(new Option('-sfp, --site-favicon-png <string>', 'Alternative favicon the server').env('TO_FAVICONPNG'))
    .addOption(new Option('-lu, --logo-url <string>', 'Alternative image url to use as logo for the server').env('TO_LOGOURL'));

program.parse(process.argv);
const options = program.opts();

// INPUT VALIDATION START ------------------------------------------------------------------------------------------------------
// filter boolean values from env and check it all
Object.entries(process.env).forEach(function ([key, value]) {
    if (key.indexOf('TO_') == 0) {
        let optKey = envToParam(key);
        // Is the env value boolean - commander set its to true if anything is entered in evn and the argument is not a string
        if (typeof options[optKey] == 'boolean' && program.getOptionValueSource(optKey) == 'env') {
            let envBoolFail = true;
            let valLow = value.toLowerCase();
            // Do we have a string "boolean" false the convert to real false
            if (valLow == 'false' || value == 0) {
                if (options[optKey] != undefined) {
                    // Assign real boolean value
                    options[optKey] = false;
                    envBoolFail = false;
                }
            }
            if (valLow == 'true' || value == 1) {
                if (options[optKey] != undefined) {
                    // Assign real boolean value
                    options[optKey] = true;
                    envBoolFail = false;
                }
            }
            if (envBoolFail) {
                program.error('Invalid ENV argument for ' + key + ' value "' + value + '" is not a boolean value');
            }
        }
        if (value === '' && program.getOptionValueSource(optKey) == 'env') {
             options[optKey] = undefined;
        }
    }
});

debug('Server started with the following options. Format = argument : value (source for value)');
Object.entries(options).forEach(function ([key, value]) {
    debug(' %s: %s (%s)',key, value, program.getOptionValueSource(key));
});

options.port = Number(options.port);
if (isNaN(options.port)) {
    program.error('Invalid argument: "port" must be a number');
}
if (options.maxSockets != undefined) {
    options.maxSockets = Number(options.maxSockets);
    if (isNaN(options.maxSockets) || options.maxSockets <= 0) {
        program.error('Invalid argument: "max-sockets" must be a positive number');
    }
}

// check landing page url
if (options.landing != undefined && !stringIsAValidUrl(options.landing)) {
    program.error('Invalid argument: "landing" must be a valid URL');
}

if (options.ipaddress != undefined && options.ipaddress != 'localhost') {
    if (/^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)(\.(?!$)|$)){4}$/.test(options.ipaddress) == false) {
        program.error('Invalid argument: "address" must be a valid IPv4');
    }
}

// check dashboard login/auth for admin
if (typeof options.dashboardUser !== typeof options.dashboardPass && (options.dashboardUser === undefined || options.dashboardPass === undefined)) {
    program.error('Both --dashboard-user and --dashboard-pass must be supplied if you want to use dashboard');

}

if (options.dashboardPass !== undefined && options.dashboardPass === options.dashboardUser) {
    program.error('--dashboard-user and --dashboard-pass parameters must be different!');
}

if (options.dashboardPass !== undefined && /^(?=(.*[a-z]){3,})(?=(.*[A-Z]){2,})(?=(.*[0-9]){2,})(?=(.*[!@#$%^&*()\-__+.]){1,}).{8,}$/.test(options.dashboardPass) == false) {
    program.error('Insecure --dashboard-pass, minimmum is 8 chars long containing at least: 3 lowercaser chars, 2 uppercase chars, 2 numeric chars and one special char(!@#$%^&*()-__+.)');
}

let fileChecks = {};
// If we are running secure we need SSL cert files
if (options.insecure !== true) {
    fileChecks['keyFile'] = true;
    fileChecks['certFile'] = true;
}
// on a public server we can use the clients database but it not mandatory
if (options.publicServer === true) {
    fileChecks['clientsFile'] = false;
} else {
    fileChecks['clientsFile'] = true;
}
Object.entries(fileChecks).forEach(function ([optKey, value]) {
    if (options[optKey] !== undefined) {
        let filChk = fileAccess(options[optKey]);
        if (filChk !== true) {
            program.error('Invalid parameter for "' + optionToParam(optKey) + '", ' + filChk);
        }
        // mandatory
    } else if (value) {
        program.error('Missing file parameter for "' + optionToParam(optKey) + '"');
    }
});
// INPUT VALIDATION END ------------------------------------------------------------------------------------------------------

// Build the main server
const server = CreateServer(options);

server.listen(options.port, options.ipaddress, () => {
    debug('Server listening on %s:%d', server.address().address, server.address().port);
});

process.on('SIGINT', () => {
    process.exit();
});

process.on('SIGTERM', () => {
    process.exit();
});

process.on('uncaughtException', (err) => {
    console.error(err);
});

process.on('unhandledRejection', (reason) => {
    console.error(reason);
});
