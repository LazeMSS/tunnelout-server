#!/usr/bin/env -S node -r esm

import 'localenv';
const {
    Command,
    Option
} = require("commander");

const {
    version
} = require("../package");

const program = new Command();

import log from 'book';
import Debug from 'debug';

import CreateServer from '../server';

const debug = Debug('localtunnel');


program
    .usage("--port <number> <options>")
    .addOption(new Option("-p, --port [number]", "Listen on this port for outside requests aka public port").default(80).env("PORT").makeOptionMandatory())
    .addOption(new Option("-s, --secure", "Use this flag to indicate proxy over https").default(true).env("SECURE").makeOptionMandatory())
    .addOption(new Option("-i, --address [number]", "IP address to bind to").default('0.0.0.0').env("IPADR"))
    .addOption(new Option("-d, --domain [string]", "Specify the base domain name. This is optional if hosting localtunnel from a regular example.com domain. This is required if hosting a localtunnel server from a subdomain (i.e. lt.example.dom where clients will be client-app.lt.example.come").env("DOMAIN"))
    .addOption(new Option("-m, --max-sockets [number]", "Maximum number of tcp sockets each client is allowed to establish at one time (the tunnels)").default(10).env("MAXSOCK"))
    .addOption(new Option("-l, --landing [string]", "The landing page for redirect from root domain").default('http://google.com').env("LANDING"))
    .version(version);

program.parse(process.argv);
const options = program.opts();
console.log(options);

const server = CreateServer({
    max_tcp_sockets: options.maxSockets,
    secure: options.secure,
    domain: options.domain,
    landing: options.landing,
});

server.listen(options.port, options.address, () => {
    debug('server listening on port: %d', server.address().port);
});

process.on('SIGINT', () => {
    process.exit();
});

process.on('SIGTERM', () => {
    process.exit();
});

process.on('uncaughtException', (err) => {
    log.error(err);
});

process.on('unhandledRejection', (reason, promise) => {
    log.error(reason);
});